<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ULTRAKILL: MAX DEMAKE V8.5 (Boss Waves Implemented & Optimized)</title>
    <style>
        /* ==================================== */
        /* CSS STYLING BLOCK - START          */
        /* ==================================== */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { display: block; }
        
        #ui, #center-msg { position: absolute; pointer-events: none; }
        #ui { top: 20px; left: 20px; }
        .hud-text { font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #hp-bar { width: 300px; height: 20px; background: #333; margin-top: 10px; border: 2px solid white; }
        #hp-fill { width: 100%; height: 100%; background: #f00; transition: width 0.1s; }
        #combo-meter {
            position: absolute; top: 100px; left: 20px; font-size: 36px; font-weight: bold;
            color: #00ffcc; text-shadow: 2px 2px 0 #000; opacity: 0; transition: opacity 0.2s, transform 0.1s;
        }
        
        #weapon-status { position: absolute; bottom: 20px; left: 20px; }
        .weapon-item { display: inline-block; margin-right: 20px; padding: 5px 10px; border: 2px solid gray; }
        .weapon-item.active { border-color: yellow; color: yellow; }
        .cooldown-bar { height: 5px; background: #555; margin-top: 3px; }
        .cooldown-fill { height: 100%; background: #00ccff; width: 0%; }
        
        #style-meter { position: absolute; right: 20px; top: 20px; text-align: right; }
        #rank { font-size: 72px; font-weight: 900; font-style: italic; color: #ccc; }
        #wave-status {
            position: absolute; top: 20px; right: 350px; font-size: 32px; font-weight: bold;
            color: #ffaa00; text-shadow: 2px 2px 0 #000;
        }
        
        #center-msg {
            top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px;
            text-align: center; pointer-events: none; z-index: 100;
        }

        #start-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200;
        }
        #start-menu h1 { font-size: 80px; color: #f00; margin-bottom: 20px; text-shadow: 5px 5px 0 #333; }
        #start-button {
            padding: 15px 30px; font-size: 30px; background-color: #0077ff; color: white;
            border: 5px solid yellow; cursor: pointer; transition: background-color 0.2s, transform 0.1s;
        }
        #start-button:hover { background-color: #0099ff; transform: scale(1.05); }
        #controls-info { margin-top: 30px; font-size: 16px; opacity: 0.8; text-align: center; }
        /* ==================================== */
        /* CSS STYLING BLOCK - END            */
        /* ==================================== */
    </style>
</head>
<body>
    <div id="start-menu">
        <h1>ULTRAKILL DEMAKE</h1>
        <button id="start-button">START CYBER GRIND</button>
        <div id="controls-info">
            WASD - Movement | W (Mid-Air) - Double Jump | CLICK - Fire | RCLICK (PKM) - Melee (Parry) | SHIFT - Dash | S (Mid-Air) - SLAM | 1-5 - Weapon Switch
        </div>
        <p style="margin-top: 20px; color: #ff00cc;">NEW: Boss enemies appear every 5 waves!</p>
    </div>

    <div id="ui" style="display:none;">
        <div class="hud-text">HEALTH</div>
        <div id="hp-bar"><div id="hp-fill"></div></div>
    </div>
    
    <div id="combo-meter"></div>

    <div id="style-meter" style="display:none;">
        <div id="score-text">SCORE: 0</div>
        <div id="rank">DESTRUCTIVE</div>
    </div>
    
    <div id="wave-status" style="display:none;">WAVE 1</div>
    
    <div id="weapon-status" style="display:none;">
        <div id="weapon-1" class="weapon-item active">1: REVOLVER<div class="cooldown-bar"><div class="cooldown-fill" id="cd-1"></div></div></div>
        <div id="weapon-2" class="weapon-item">2: SHOTGUN<div class="cooldown-bar"><div class="cooldown-fill" id="cd-2"></div></div></div>
        <div id="weapon-3" class="weapon-item">3: RAILGUN<div class="cooldown-bar"><div class="cooldown-fill" id="cd-3"></div></div></div>
        <div id="weapon-4" class="weapon-item">4: MACHINE<div class="cooldown-bar"><div class="cooldown-fill" id="cd-4"></div></div></div>
        <div id="weapon-5" class="weapon-item">5: ROCKET<div class="cooldown-bar"><div class="cooldown-fill" id="cd-5"></div></div></div>
    </div>

    <div id="center-msg" style="display:none;">
        <h1 style="color:red">YOU DIED</h1>
        <p>PRESS R TO RESTART</p>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // ====================================
    //        GLOBAL VARIABLES & SETUP
    // ====================================
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements References
    const comboMeterEl = document.getElementById('combo-meter');
    const centerMsgEl = document.getElementById('center-msg');
    const waveStatusEl = document.getElementById('wave-status');
    
    // Core Game State Variables
    let gameState = 'MENU'; 
    let score = 0;
    let stylePoints = 0;
    let activeWeapon = 1; 
    let mouseButtons = { left: false, right: false };
    let screenShake = 0;
    
    // Combo System Variables
    let comboCount = 0;
    let comboTimer = 0;
    const MAX_COMBO_TIME = 120; // 2 seconds
    let comboMultiplier = 1.0;
    
    // Wave Management Variables
    let currentWave = 1;
    let enemiesToSpawnInWave = 5;
    let waveSpawnsCompleted = false;
    let waveStartTime = 0;
    const WAVE_INTERVAL = 600; // 10 seconds between waves
    
    // Enemy Spawning Constants
    const MIN_SAFE_PLAYER_DISTANCE = 400; 
    const MIN_SAFE_ENEMY_DISTANCE = 50;   
    const MAX_SPAWN_DISTANCE = 800; 

    // Arena Definition
    const arena = { floorHeight: 30 };
    
    // --- PLAYER OBJECT ---
    const player = {
        x: 0, y: 0, radius: 15, speed: 5, hp: 100, maxHp: 100, angle: 0,
        dashCooldown: 0, dashTime: 0,
        revolverCooldown: 0, shotgunCooldown: 0, railgunCooldown: 0,
        machineCooldown: 0, rocketCooldown: 0, meleeCooldown: 0,
        isGrounded: true, canDoubleJump: true, isSlamming: false,
        velocityY: 0, gravity: 0.5, jumpPower: -15
    };

    // Input States
    const keys = { w: false, a: false, s: false, d: false, shift: false };
    const mouse = { x: 0, y: 0 };

    // Entity Arrays
    let bullets = []; let projectiles = []; 
    let enemies = []; let particles = []; let texts = []; 
    let waveSpawnQueue = [];
    let spawnIntervalTimer = 0;
    const SPAWN_DELAY = 30; // 0.5 seconds between initial spawns

    // Detailed Weapon Data
    const weaponData = {
        1: { name: "REVOLVER", cooldownMax: 10, cooldownKey: "revolverCooldown", damage: 100, styleMultiplier: 1.0, piercing: false },
        2: { name: "SHOTGUN", cooldownMax: 45, cooldownKey: "shotgunCooldown", pelletCount: 6, pelletDamage: 50, styleMultiplier: 0.4, spread: 0.8 },
        3: { name: "RAILGUN", cooldownMax: 300, cooldownKey: "railgunCooldown", damage: 500, styleMultiplier: 5.0, piercing: true, color: '#00ccff' },
        4: { name: "MACHINE", cooldownMax: 10, cooldownKey: "machineCooldown", damage: 30, styleMultiplier: 0.2, spread: 0.1 },
        5: { name: "ROCKET", cooldownMax: 60, cooldownKey: "rocketCooldown", damage: 300, styleMultiplier: 1.5, explosionRadius: 100 } 
    };

    // Enemy Type Data
    const enemyTypes = {
        'filth': { maxHp: 200, color: '#aaa', speed: 2.0, size: 15, baseScore: 100 },
        'stray': { maxHp: 350, color: '#990099', speed: 1.0, rangedCooldown: 180, projectileDamage: 10, size: 15, baseScore: 200 },
        'swarm': { maxHp: 50, color: '#ffcc00', speed: 5.0, size: 8, baseScore: 50 },
        // --- BOSS DATA ---
        'boss': { maxHp: 5000, color: '#ff00ff', speed: 0.5, size: 50, baseScore: 5000, rangedCooldown: 90, projectileDamage: 30 } 
    };
    
    // --- AUDIO CONTEXT (Simplified) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0, audioCtx.currentTime); 
        
         if (type === 'shoot') { osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'hit_enemy') { osc.type = 'triangle'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05); osc.start(); osc.stop(audioCtx.currentTime + 0.05);
        } else if (type === 'kill') { osc.type = 'sine'; osc.frequency.setValueAtTime(440, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'dash') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2); osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        } else if (type === 'parry') { osc.type = 'triangle'; osc.frequency.setValueAtTime(1200, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'hit_player') { osc.type = 'square'; osc.frequency.setValueAtTime(50, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }
    }

    // ====================================
    //       INITIALIZATION & CORE FLOW
    // ====================================
    
    function setupCanvasAndPlayerPosition() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height - player.radius - arena.floorHeight; 
    }

    function resetGame() {
        setupCanvasAndPlayerPosition(); 
        player.hp = player.maxHp; player.dashCooldown = 0; player.dashTime = 0;
        player.isGrounded = true; player.canDoubleJump = true; player.isSlamming = false;
        player.velocityY = 0;
        
        enemies = []; bullets = []; particles = []; projectiles = []; texts = [];
        waveSpawnQueue = []; spawnIntervalTimer = 0;
        
        score = 0; stylePoints = 0; comboCount = 0; comboTimer = 0; comboMultiplier = 1.0;
        
        currentWave = 1; enemiesToSpawnInWave = 5; waveSpawnsCompleted = false; waveStartTime = 0;
        
        centerMsgEl.style.display = 'none'; waveStatusEl.style.display = 'block';
        updateUI(); 
    }
    
    function startGame() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        gameState = 'PLAYING';
        document.getElementById('start-menu').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('style-meter').style.display = 'block';
        document.getElementById('weapon-status').style.display = 'block';
        
        resetGame(); 
        startNextWave(); // Start the first wave
    }
    
    // ====================================
    //            INPUT HANDLERS
    // ====================================

    window.addEventListener('resize', setupCanvasAndPlayerPosition);
    window.addEventListener('keydown', (e) => {
        if (e.key === 'r' && gameState === 'GAMEOVER') { startGame(); return; }
        if (gameState !== 'PLAYING') return; 

        if (e.key === 'w' || e.key === 'W') { 
            if (keys.w === false && player.isGrounded) { player.velocityY = player.jumpPower; player.isGrounded = false; } 
            else if (keys.w === false && player.canDoubleJump) { player.velocityY = player.jumpPower * 0.8; player.canDoubleJump = false; }
            keys.w = true;
        }
        if (e.key === 'a' || e.key === 'A') keys.a = true;
        if (e.key === 's' || e.key === 'S') { 
            keys.s = true;
            if (!player.isGrounded && !player.isSlamming) { player.isSlamming = true; player.velocityY = 25; }
        }
        if (e.key === 'd' || e.key === 'D') keys.d = true;
        if (e.key === 'Shift') keys.shift = true;
        
        if (e.key === '1') activeWeapon = 1; if (e.key === '2') activeWeapon = 2;
        if (e.key === '3') activeWeapon = 3; if (e.key === '4') activeWeapon = 4;
        if (e.key === '5') activeWeapon = 5;
    });

    window.addEventListener('keyup', (e) => {
        if (gameState !== 'PLAYING') return;
        if (e.key === 'w' || e.key === 'W') keys.w = false;
        if (e.key === 'a' || e.key === 'A') keys.a = false;
        if (e.key === 's' || e.key === 'S') keys.s = false;
        if (e.key === 'd' || e.key === 'D') keys.d = false;
        if (e.key === 'Shift') keys.shift = false;
    });

    window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', (e) => {
        if (gameState !== 'PLAYING') return;
        if (e.button === 0) mouseButtons.left = true;
        if (e.button === 2) mouseButtons.right = true;
    });
    window.addEventListener('mouseup', (e) => {
        if (e.button === 0) mouseButtons.left = false;
        if (e.button === 2) mouseButtons.right = false;
    });
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.getElementById('start-button').addEventListener('click', startGame);

    // ====================================
    //         COMBAT MECHANICS
    // ====================================
    
    function applyDamage(e, damage, styleMult) {
        if (e.hp <= 0) return; 
        const finalDamage = damage * comboMultiplier;
        e.hp -= finalDamage;
        
        playSound('hit_enemy');
        spawnDamageParticles(e, e.hp <= 0 ? 'red' : 'orange');

        const lifestealAmount = finalDamage * 0.05; 
        player.hp = Math.min(player.maxHp, player.hp + lifestealAmount);

        if (e.hp <= 0) {
            let index = enemies.findIndex(enemy => enemy === e);
            if (index !== -1) { killEnemy(e, index, styleMult); }
        }
    }

    function fireHitscan(angle, styleMultiplier, damage, piercing, color = 'yellow') {
        screenShake = 5;
        const length = canvas.width * 2;
        bullets.push({
            x1: player.x, y1: player.y, x2: player.x + Math.cos(angle) * length, 
            y2: player.y + Math.sin(angle) * length, life: 5, color: color
        });

        const hitEnemies = [];
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let dx = e.x - player.x; let dy = e.y - player.y;
            let angleToEnemy = Math.atan2(dy, dx);
            let angleDiff = angleToEnemy - angle;
            while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            if (Math.abs(angleDiff) < 0.15) { hitEnemies.push(e); }
        }

        hitEnemies.sort((a, b) => {
            const distA = Math.hypot(a.x - player.x, a.y - player.y);
            const distB = Math.hypot(b.x - player.x, b.y - player.y);
            return distA - distB;
        });

        for (let e of hitEnemies) {
            applyDamage(e, damage, styleMultiplier);
            if (!piercing && e.hp > 0) { break; }
        }
    }
    
    function meleeAttack() {
        if (player.meleeCooldown > 0) return;
        player.meleeCooldown = 30;

        let parried = false;
        const parryRadius = player.radius * 2 + 10;
        
        // Parry check on enemy projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            let dist = Math.hypot(p.x - player.x, p.y - player.y);
            if (dist < parryRadius && p.isEnemy) {
                playSound('parry'); screenShake = 10;
                player.hp = Math.min(player.maxHp, player.hp + 50); 
                stylePoints += 200;
                texts.push({x: player.x, y: player.y - 30, text: "PARRY!", life: 40, color: 'lime'});
                p.isEnemy = false; p.vx = -p.vx * 4; p.vy = -p.vy * 4;
                p.color = '#00ff00'; p.damage *= 5; 
                parried = true;
                comboTimer = MAX_COMBO_TIME; 
                break;
            }
        }
        
        // Melee damage to nearby enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let dist = Math.hypot(e.x - player.x, e.y - player.y);
            if (dist < player.radius + e.radius + 10) { applyDamage(e, 50, 1.0); }
        }
    }

    function shoot() {
        const data = weaponData[activeWeapon];
        if (player[data.cooldownKey] > 0) return;
        
        const aimAngle = player.angle;
        player[data.cooldownKey] = data.cooldownMax; 

        if (activeWeapon === 1) { // Revolver
            playSound('shoot'); fireHitscan(aimAngle, data.styleMultiplier, data.damage, data.piercing); 
        } else if (activeWeapon === 2) { // Shotgun
            playSound('shoot');
            for (let i = 0; i < data.pelletCount; i++) {
                const spread = (Math.random() - 0.5) * data.spread; 
                fireHitscan(aimAngle + spread, data.styleMultiplier, data.pelletDamage, false); 
            }
        } else if (activeWeapon === 3) { // Railgun
            playSound('rail'); fireHitscan(aimAngle, data.styleMultiplier, data.damage, data.piercing, data.color); 
        } else if (activeWeapon === 4) { // Machine Pistol
            playSound('shoot'); fireHitscan(aimAngle + (Math.random() - 0.5) * data.spread, data.styleMultiplier, data.damage, false);
        } else if (activeWeapon === 5) { // ROCKET LAUNCHER
            playSound('shoot'); 
            projectiles.push({
                x: player.x, y: player.y, vx: Math.cos(aimAngle) * 12, vy: Math.sin(aimAngle) * 12,
                radius: 10, color: 'red', isEnemy: false, damage: data.damage, 
                isExplosive: true, explosionRadius: data.explosionRadius 
            });
        }
    }
    
    // ====================================
    //         UTILITY & SPAWN LOGIC
    // ====================================

    function killEnemy(e, index, styleMultiplier = 1) { 
        playSound('kill');
        comboCount++;
        comboTimer = MAX_COMBO_TIME; 
        stylePoints += enemyTypes[e.type].baseScore * styleMultiplier * comboMultiplier; 
        texts.push({x: e.x, y: e.y - 20, text: `+KILL x${comboCount}`, life: 30, color: 'cyan'});
        
        // Spawn death particles (gore)
        for(let j=0; j<15; j++) {
            particles.push({
                x: e.x, y: e.y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                life: 30 + Math.random() * 20, color: 'red', size: Math.random() * 4 + 2, 
                isGore: true, gravity: 0.2
            });
        }
        
        enemies.splice(index, 1);
        score += enemyTypes[e.type].baseScore;
    }

    function spawnDamageParticles(target, color) {
        for(let j=0; j<5; j++) {
            particles.push({
                x: target.x, y: target.y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                life: 15, color: color, size: Math.random() * 3 + 1, isGore: false, gravity: 0 
            });
        }
    }

    function spawnExplosionParticles(x, y, count) {
        for(let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                life: 40 + Math.random() * 30, color: Math.random() < 0.5 ? 'orange' : 'yellow', 
                size: Math.random() * 5 + 3, isGore: false, gravity: 0.1, friction: 0.92
            });
        }
    }
    
    /**
     * @function spawnEnemy
     * @description Spawns a new enemy safely away from the player and other enemies.
     */
    function spawnEnemy(forceType = null) {
        let x, y;
        const groundY = canvas.height - player.radius - arena.floorHeight;
        
        const enemyTypeKey = forceType || (Math.random() < 0.8 ? 'filth' : 'stray');
        const typeData = enemyTypes[enemyTypeKey];
        const newEnemyRadius = typeData.size;

        let attempts = 0;
        let isSafe = false;

        do {
            let angle = Math.random() * Math.PI * 2;
            let dist = MIN_SAFE_PLAYER_DISTANCE + Math.random() * (MAX_SPAWN_DISTANCE - MIN_SAFE_PLAYER_DISTANCE);

            x = player.x + Math.cos(angle) * dist;
            y = groundY; 
            isSafe = true;

            if (x < newEnemyRadius || x > canvas.width - newEnemyRadius) {
                isSafe = false; attempts++; continue;
            }
            
            // CRITICAL ENEMY-ENEMY SPAWN CHECK
            for (const existingEnemy of enemies) {
                const distToEnemy = Math.hypot(x - existingEnemy.x, y - existingEnemy.y);
                if (distToEnemy < MIN_SAFE_ENEMY_DISTANCE + existingEnemy.radius + newEnemyRadius) {
                    isSafe = false; break;
                }
            }
            attempts++;
        } while (!isSafe && attempts < 20); 

        // Fallback
        if (!isSafe) { x = Math.random() < 0.5 ? 0 + newEnemyRadius : canvas.width - newEnemyRadius; y = groundY; }
        
        const newEnemy = {
            x: x, y: y, radius: typeData.size, hp: typeData.maxHp,
            speed: typeData.speed + Math.random() * 1.5 * (currentWave / 10),
            type: enemyTypeKey, shootCooldown: typeData.rangedCooldown || 0
        };
        
        enemies.push(newEnemy);
    }
    
    // --- WAVE LOGIC ---

    /**
     * @function calculateWaveComposition
     * @description Determines the mix of enemies and includes boss logic.
     */
    function calculateWaveComposition(wave) {
        if (wave % 5 === 0) {
            // BOSS WAVE LOGIC
            return { boss: 1, filth: 0, stray: 0, swarm: 0 };
        }

        const totalEnemies = 5 + wave * 2;
        let filthCount = Math.floor(totalEnemies * 0.5);
        let strayCount = Math.floor(totalEnemies * 0.3);
        let swarmCount = totalEnemies - filthCount - strayCount; 
        
        // Add more difficult enemies over time
        if (wave > 5) { strayCount += Math.floor((wave - 5) / 5); }

        return { filth: filthCount, stray: strayCount, swarm: swarmCount };
    }

    function startNextWave() {
        currentWave++;
        const composition = calculateWaveComposition(currentWave);
        
        enemiesToSpawnInWave = composition.filth + composition.stray + composition.swarm + (composition.boss || 0);
        waveSpawnsCompleted = false;
        waveStartTime = Date.now();
        
        if (composition.boss) {
            texts.push({x: canvas.width/2, y: canvas.height/4, text: "TITAN HUSK APPEARS!", life: 180, color: 'red'});
        } else {
            texts.push({x: canvas.width/2, y: canvas.height/4, text: `WAVE ${currentWave} START!`, life: 90, color: 'gold'});
        }
        
        updateUI();
        spawnWaveEnemies(composition);
    }
    
    function spawnWaveEnemies(composition) {
        waveSpawnQueue = [];
        
        // Add Boss first for immediate spawn
        for (let i = 0; i < (composition.boss || 0); i++) waveSpawnQueue.push('boss');

        for (let i = 0; i < composition.filth; i++) waveSpawnQueue.push('filth');
        for (let i = 0; i < composition.stray; i++) waveSpawnQueue.push('stray');
        for (let i = 0; i < composition.swarm; i++) waveSpawnQueue.push('swarm');
        
        // Shuffle the rest of the queue (Boss always spawns first if present)
        if (composition.boss) {
            const boss = waveSpawnQueue.shift(); // Remove boss
            for (let i = waveSpawnQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [waveSpawnQueue[i], waveSpawnQueue[j]] = [waveSpawnQueue[j], waveSpawnQueue[i]];
            }
            waveSpawnQueue.unshift(boss); // Put boss back at the front
        } else {
             for (let i = waveSpawnQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [waveSpawnQueue[i], waveSpawnQueue[j]] = [waveSpawnQueue[j], waveSpawnQueue[i]];
            }
        }
        
        spawnIntervalTimer = 0;
    }

    function handleWaveSpawning() {
        if (waveSpawnQueue.length > 0) {
            spawnIntervalTimer++;
            
            // Faster spawn delay if it's a boss, or if low enemy count
            let currentDelay = (waveSpawnQueue[0] === 'boss') ? 1 : SPAWN_DELAY;

            if (spawnIntervalTimer >= currentDelay && enemies.length < 15) {
                const enemyType = waveSpawnQueue.shift();
                spawnEnemy(enemyType);
                spawnIntervalTimer = 0;
            }
        }
        
        // Check for wave end conditions
        if (waveSpawnQueue.length === 0 && enemies.length === 0 && gameState === 'PLAYING') {
            if (!waveSpawnsCompleted) {
                 waveSpawnsCompleted = true;
                 texts.push({x: canvas.width/2, y: canvas.height/3, text: "WAVE CLEARED!", life: 120, color: 'lime'});
            }
            
            if ((Date.now() - waveStartTime) > WAVE_INTERVAL) {
                 startNextWave();
            }
        }
    }
    
    // ====================================
    //        MAIN GAME LOOP: UPDATE
    // ====================================

    function update() {
        if (gameState !== 'PLAYING') {
            if (stylePoints > 0) stylePoints -= 0.2;
            updateUI();
            requestAnimationFrame(update);
            return; 
        }
        
        handleWaveSpawning();
        
        // 1. Combo Decay Logic
        if (comboTimer > 0) {
            comboTimer--;
            comboMultiplier = 1.0 + (comboCount * 0.1); 
            comboMeterEl.style.opacity = 1;
        } else {
            comboCount = 0;
            comboMultiplier = 1.0;
            comboMeterEl.style.opacity = 0;
        }
        
        // 2. Cooldowns and Input
        for (const key in weaponData) { player[weaponData[key].cooldownKey] = Math.max(0, player[weaponData[key].cooldownKey] - 1); }
        player.meleeCooldown = Math.max(0, player.meleeCooldown - 1);
        player.dashCooldown = Math.max(0, player.dashCooldown - 1);

        if (mouseButtons.left) shoot();
        if (mouseButtons.right) meleeAttack();

        player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

        // 3. Player Physics and Movement
        const groundY = canvas.height - player.radius - arena.floorHeight;
        if (!player.isGrounded) { player.velocityY += player.gravity; }
        player.y += player.velocityY;

        // Ground collision and Slam handling
        if (player.y >= groundY) {
            player.y = groundY; player.velocityY = 0;
            if (player.isGrounded === false) { player.isGrounded = true; player.canDoubleJump = true; }

            if (player.isSlamming) {
                screenShake = 15;
                texts.push({x: player.x, y: player.y - 10, text: "GOTTEM", life: 50, color: 'orange'});
                enemies.forEach((e) => {
                    let dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist < 100) { applyDamage(e, 150, 1.5); }
                });
            }
            player.isSlamming = false;
        } else { player.isGrounded = false; }
        
        // Horizontal Movement and Dash
        let dx = 0;
        if (!player.isSlamming) {
            if (keys.a) dx -= 1;
            if (keys.d) dx += 1;
        }

        if (keys.shift && player.dashCooldown <= 0 && (dx !== 0 || !player.isGrounded)) {
            player.dashTime = 10; player.dashCooldown = 60; playSound('dash');
        }

        let currentSpeed = player.speed;
        if (player.dashTime > 0) { currentSpeed *= 4; player.dashTime--; }
        if (dx !== 0) { player.x += dx * currentSpeed; }
        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        
        // 4. Enemy Updates (Movement, Ranged Attacks, Contact Damage)
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let typeData = enemyTypes[e.type];
            let ex = player.x - e.x;
            let ey = player.y - e.y;
            let dist = Math.hypot(ex, ey);
            
            // Movement 
            e.x += (ex/dist) * e.speed; 
            e.x = Math.max(e.radius, Math.min(canvas.width - e.radius, e.x)); 
            
            // Ranged enemy (Stray/Boss) attack
            if (e.type === 'stray' || e.type === 'boss') {
                e.shootCooldown--;
                if (e.shootCooldown <= 0 && dist < 800) {
                    e.shootCooldown = typeData.rangedCooldown; 
                    const angleToPlayer = Math.atan2(ey, ex);
                    projectiles.push({
                        x: e.x, y: e.y, vx: Math.cos(angleToPlayer) * 8, 
                        vy: Math.sin(angleToPlayer) * 8, radius: 8, color: e.type === 'boss' ? 'red' : 'purple', 
                        isEnemy: true, damage: typeData.projectileDamage, isExplosive: false
                    });
                }
            }
            
            // Contact damage
            if (dist < player.radius + e.radius) {
                if (player.dashTime <= 0 && player.isSlamming === false) { 
                    player.hp -= (e.type === 'boss' ? 5 : 1); 
                    screenShake = 3; playSound('hit_player');
                    if (player.hp <= 0) { gameState = 'GAMEOVER'; centerMsgEl.style.display = 'block'; } 
                }
            }
        }

        // 5. Projectile Updates
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx; p.y += p.vy;
            if (p.x < -100 || p.x > canvas.width + 100 || p.y < -100 || p.y > canvas.height + 100) { projectiles.splice(i, 1); continue; }

            let hit = false;
            if (p.isEnemy) {
                let distToPlayer = Math.hypot(p.x - player.x, p.y - player.y);
                if (distToPlayer < player.radius + p.radius) {
                    if (player.dashTime <= 0) { 
                        player.hp -= p.damage; playSound('hit_player'); screenShake = 5; 
                        if (player.hp <= 0) { gameState = 'GAMEOVER'; centerMsgEl.style.display = 'block'; } 
                    }
                    hit = true;
                }
            } else {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    let distToEnemy = Math.hypot(p.x - e.x, p.y - e.y);

                    if (distToEnemy < e.radius + p.radius) {
                        if (p.isExplosive) {
                            screenShake = 10; spawnExplosionParticles(p.x, p.y, 15);
                            enemies.forEach((target) => {
                                let explDist = Math.hypot(target.x - p.x, target.y - p.y);
                                if (explDist < p.explosionRadius) { 
                                    let damage = p.damage / (1 + explDist/(p.explosionRadius/2)); 
                                    applyDamage(target, damage, weaponData[5].styleMultiplier);
                                }
                            });
                        } else {
                            applyDamage(e, p.damage, 1.0); 
                        }
                        hit = true; break;
                    }
                }
            }
            if (hit || p.isExplosive) { projectiles.splice(i, 1); continue; }
        }

        // 6. Particle and Floating Text Decay
        for (let i = particles.length - 1; i >= 0; i--) { 
            let p = particles[i]; 
            p.x += p.vx; p.y += p.vy; p.life--; 
            p.vx *= p.friction || 0.9; p.vy *= p.friction || 0.9; 
            if (p.gravity) p.vy += p.gravity; 
            if (p.life <= 0) particles.splice(i, 1); 
        }
        for (let i = texts.length - 1; i >= 0; i--) { 
            let t = texts[i]; t.y -= 1; t.life--; 
            if (t.life <= 0) texts.splice(i, 1); 
        }
        
        // 7. UI Update
        if (stylePoints > 0) stylePoints -= 0.2;
        updateUI();

        // 8. Final Game Over Check
        if (player.hp <= 0 && gameState !== 'GAMEOVER') {
             gameState = 'GAMEOVER'; centerMsgEl.style.display = 'block'; 
        }

        requestAnimationFrame(update);
    }
    
    // ====================================
    //              UI & RANKING
    // ====================================

    function updateUI() {
        document.getElementById('hp-fill').style.width = player.hp + '%';
        document.getElementById('score-text').innerText = 'SCORE: ' + Math.floor(score);
        waveStatusEl.innerText = `WAVE ${currentWave} | E: ${enemies.length}/${enemiesToSpawnInWave}`;
        
        comboMeterEl.innerText = comboCount > 1 ? `COMBO x${comboCount}` : '';
        
        for (let i = 1; i <= 5; i++) {
            const el = document.getElementById(`weapon-${i}`);
            const cdFill = document.getElementById(`cd-${i}`);
            const data = weaponData[i];
            el.classList.toggle('active', activeWeapon === i);
            
            const currentCd = player[data.cooldownKey];
            const percent = (currentCd / data.cooldownMax) * 100;
            cdFill.style.width = percent + '%';
        }

        let rankEl = document.getElementById('rank');
        let rank = "DESTRUCTIVE"; let color = "#ccc";
        
        if (stylePoints > 1000) { rank = "CHAOTIC"; color = "yellow"; }
        if (stylePoints > 2500) { rank = "BRUTAL"; color = "orange"; }
        if (stylePoints > 5000) { rank = "ANARCHIC"; color = "red"; }
        if (stylePoints > 8000) { rank = "SUPREME"; color = "#f0f"; }
        if (stylePoints > 12000) { rank = "ULTRAKILL"; color = "gold"; }
        
        rankEl.innerText = rank;
        rankEl.style.color = color;
    }

    // ====================================
    //       MAIN GAME LOOP: DRAW
    // ====================================

    function draw() {
        let shakeX = 0, shakeY = 0;
        if (screenShake > 0) {
            shakeX = (Math.random() - 0.5) * screenShake;
            shakeY = (Math.random() - 0.5) * screenShake;
            screenShake *= 0.9;
        }
        
        ctx.setTransform(1, 0, 0, 1, shakeX, shakeY);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState !== 'MENU') {
            // 1. Grid & Ground
            ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.beginPath();
            const gridStep = 50;
            for(let x = 0; x < canvas.width; x+=gridStep) { ctx.moveTo(x,0); ctx.lineTo(x, canvas.height); }
            for(let y = 0; y < canvas.height - arena.floorHeight; y+=gridStep) { ctx.moveTo(0,y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();
            ctx.fillStyle = '#111'; ctx.fillRect(0, canvas.height - arena.floorHeight, canvas.width, arena.floorHeight);
            
            // 2. Particles
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); });

            // 3. Enemies
            enemies.forEach(e => {
                const typeData = enemyTypes[e.type];
                const hpRatio = e.hp / typeData.maxHp; 
                ctx.fillStyle = typeData.color; 
                
                if (e.type === 'swarm') {
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fill();
                } else if (e.type === 'boss') {
                    // Boss: large square for distinction
                    ctx.fillRect(e.x - e.radius, e.y - e.radius, e.radius * 2, e.radius * 2);
                } else {
                    // Triangle for filth/stray
                    ctx.beginPath(); ctx.moveTo(e.x, e.y - e.radius); ctx.lineTo(e.x + e.radius * 0.7, e.y + e.radius * 0.7);
                    ctx.lineTo(e.x - e.radius * 0.7, e.y + e.radius * 0.7); ctx.fill();
                }
                
                // Draw HP bar
                ctx.fillStyle = 'red';
                ctx.fillRect(e.x - e.radius, e.y + e.radius + 5, e.radius * 2 * hpRatio, 3);
                ctx.strokeStyle = 'white';
                ctx.strokeRect(e.x - e.radius, e.y + e.radius + 5, e.radius * 2, 3);
            });
            
            // 4. Projectiles
            projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill(); });

            // 5. Player (V1)
            ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
            ctx.fillStyle = (player.dashTime > 0) ? 'gold' : '#0077ff';
            if (player.isSlamming) ctx.fillStyle = 'orange';

            ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill();
            ctx.restore();

            // Melee/Parry radius indicator
            if (player.meleeCooldown > 15) { 
                ctx.strokeStyle = 'white'; ctx.lineWidth = 5; ctx.beginPath();
                ctx.arc(player.x, player.y, 40, 0, Math.PI * 2); ctx.stroke();
            }

            // 6. Bullets (Hitscan rays)
            ctx.lineWidth = 3;
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                ctx.strokeStyle = `rgba(${b.color === 'yellow' ? '255, 255, 0' : '0, 204, 255'}, ${b.life/5})`; 
                ctx.beginPath(); ctx.moveTo(b.x1, b.y1); ctx.lineTo(b.x2, b.y2); ctx.stroke();
                b.life--;
                if(b.life<=0) bullets.splice(i, 1);
            }

            // 7. Floating Text
            ctx.font = "20px Courier New";
            texts.forEach(t => { ctx.fillStyle = t.color || "white"; ctx.fillText(t.text, t.x, t.y); });
        }

        requestAnimationFrame(draw);
    }

    // --- CRITICAL GAME START SEQUENCE ---
    function init() {
        setupCanvasAndPlayerPosition(); 
        update(); 
        draw(); 
        
        // Initial setup for the first wave
        if (currentWave === 1 && enemies.length === 0 && waveSpawnQueue.length === 0) {
            const composition = calculateWaveComposition(1);
            enemiesToSpawnInWave = composition.filth + composition.stray + composition.swarm + (composition.boss || 0);
            spawnWaveEnemies(composition);
        }
    }

    window.addEventListener('load', init);

</script>
</body>
</html>